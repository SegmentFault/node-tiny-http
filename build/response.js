// Generated by CoffeeScript 2.3.2
(function() {
  var Cookie, Response, Status, Stream, Zlib, patchOriginalResponse;

  Cookie = require('cookie');

  Status = require('statuses');

  Zlib = require('zlib');

  Stream = require('stream');

  // make a monkey patch for original response object
  patchOriginalResponse = function(res) {
    var originalWrite;
    originalWrite = res.write;
    res.bytes = 0;
    return res.write = function(...args) {
      var buf;
      buf = args[0];
      this.bytes += buf.length;
      return originalWrite.apply(this, args);
    };
  };

  Response = class Response {
    constructor(res1, req, options1) {
      var acceptEncoding;
      this.res = res1;
      this.options = options1;
      this.$statusCode = 200;
      this.$headers = {
        'content-type': 'text/html; charset=utf-8'
      };
      this.$cookies = [];
      this.$startTime = Date.now();
      this.$stream = null;
      this.$content = null;
      this.responded = false;
      if (this.options.compression) {
        acceptEncoding = req.headers['accept-encoding'];
        if (acceptEncoding != null) {
          if (acceptEncoding.match(/\bdeflate\b/)) {
            this.$stream = Zlib.createDeflate();
            this.$headers['content-encoding'] = 'deflate';
          } else if (acceptEncoding.match(/\bgzip\b/)) {
            this.$stream = Zlib.createGzip();
            this.$headers['content-encoding'] = 'gzip';
          }
        }
      }
      if (this.$stream == null) {
        this.$stream = new Stream.PassThrough;
      }
      patchOriginalResponse(this.res);
    }

    // set content
    content(val) {
      this.$content = val;
      return this;
    }

    // set status code
    status(code) {
      this.$statusCode = Status(code);
      return this;
    }

    // set cookie
    cookie(key, val, options) {
      this.$cookies.push(Cookie.serialize(key, val, options));
      return this;
    }

    // set header
    header(key, val) {
      key = key.toLowerCase();
      this.$headers[key] = val;
      return this;
    }

    // set finish
    finish(finish) {
      this.finish = finish;
      return this.res.on('finish', () => {
        return this.finish.call(this, this.res.statusCode, this.res.bytes, Date.now() - this.$startTime);
      });
    }

    
    // respond
    respond() {
      var key, ref, val;
      this.res.statusCode = this.$statusCode;
      this.res.statusMessage = Status[this.$statusCode];
      ref = this.$headers;
      for (key in ref) {
        val = ref[key];
        key = key.replace(/(^|-)([a-z])/g, function(m, a, b) {
          return a + b.toUpperCase();
        });
        this.res.setHeader(key, val);
      }
      if (this.$cookies.length > 0) {
        this.res.setHeader('Set-Cookie', this.$cookies);
      }
      this.$stream.pipe(this.res);
      if (this.$content instanceof Stream.Readable) {
        return this.$content.pipe(this.$stream);
      } else {
        return this.$stream.end(this.$content);
      }
    }

  };

  module.exports = Response;

}).call(this);
